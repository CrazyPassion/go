# Go 设计规则
- 大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。
- 大写字母开头的函数也是一样，相当于class中的带public关键词的公有函数；小写字母开头的就是有private关键词的私有函数。
- 由于长度也是数组类型的一部分，因此[3]int与[4]int是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针
- 在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫slice.slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度.
- slice的默认开始位置是0，ar[:n]等价于ar[0:n]
- slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]
- 如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]
- 对于slice有几个有用的内置函数：
    - len 获取slice的长度
    - cap 获取slice的最大容量
    - append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice
    - copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数
- 使用map过程中需要注意的几点：
    - map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取
    - map的长度是不固定的，也就是和slice一样，也是一种引用类型
    - 内置的len函数同样适用于map，返回map拥有的key的数量
    - map的值可以很方便的修改，通过numbers["one"]=11可以很容易的把key为one的字典值改为11
    - map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制
    - map的初始化可以通过key:val的方式初始化值，同时map内置有判断是否存在key的方式
``````